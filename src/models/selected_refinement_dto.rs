/*
 * GroupBy Retail
 *
 * GroupBy Retail API
 *
 * The version of the OpenAPI document: 0.0
 * Contact: ops@groupbyinc.com
 * Generated by: https://openapi-generator.tech
 */

/// SelectedRefinementDto : Refinement the shopper has selected for filtering.



#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelectedRefinementDto {
    /// The name of the navigation the refinement is for.
    #[serde(rename = "navigationName")]
    pub navigation_name: String,
    #[serde(rename = "type")]
    pub r#type: Box<crate::models::NavigationTypeDto>,
    /// Value of selected refinement, if type is value.
    #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// The lowest end or value of the range, if applicable.
    #[serde(rename = "low", skip_serializing_if = "Option::is_none")]
    pub low: Option<f64>,
    /// The highest end or value of the range, if applicable.
    #[serde(rename = "high", skip_serializing_if = "Option::is_none")]
    pub high: Option<f64>,
    /// Field which is indicated that it is dynamic navigation.
    #[serde(rename = "source", skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// Navigation multiselect. Indicate that it is possibly to select more than one navigation value due to search request.
    #[serde(rename = "or", skip_serializing_if = "Option::is_none")]
    pub or: Option<bool>,
}

impl SelectedRefinementDto {
    /// Refinement the shopper has selected for filtering.
    pub fn new(navigation_name: String, r#type: crate::models::NavigationTypeDto) -> SelectedRefinementDto {
        SelectedRefinementDto {
            navigation_name,
            r#type: Box::new(r#type),
            value: None,
            low: None,
            high: None,
            source: None,
            or: None,
        }
    }
}


